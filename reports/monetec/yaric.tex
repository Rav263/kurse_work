\documentclass[conference]{IEEEtran}
\usepackage[russian]{babel} % rus
\usepackage{fontspec} % rus
\usepackage[T1,T2A]{fontenc} % rus
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\setmainfont{Liberation Serif} % rus

\begin{document}

\title{
Исследование применимости алгоритмов обработки пакетов с сохранением
состояния в одной архитектуре сетевого процессорного устройства\\
}

\maketitle

\begin{abstract}
В данной работе рассматривается сетевое процессорное устройство,
основанное на специализированных вычислительных ядрах,
предназначенное для обработки пакетов в сетевых устройствах (например,
в коммутаторах).

В настоящее время в программно конфигурируемых сетях (ПКС) развивается
такой класс алгоритмов обработки пакетов, как алгоритмы обработки
пакетов с хранением состояния. При использовании алгоритмов данного типа
часть управляющей информации переносится из плоскости управления ПКС
в плоскость передачи данных. Однако использование подобных алгоритмов
требует поддержки со стороны архитектуры сетевого процессорного устройства,
так как требуются ресурсы для хранения и преобразования состояния
алгоритма обработки пакетов.

В работе предлагаются модификации архитектуры сетевого процессорного
устройства, позволяющие применять алгоритмы обработки пакетов с хранением
состояния. Проводится экспериментальное исследование модифицированной
архитектуры, направленное на измерение характеристик данной
архитектуры. В результате экспериментального исследования
показана применимость данного подхода, оценены энергопотребление и
пропускная способность СПУ.
\end{abstract}


\section{Введение}
В настоящее время активно развиваются программно конфигурируемые
сети (ПКС)~\cite{bib:Smelyanskiy:SDN}. Основой технологии ПКС является
размещение управляющих функций
сети на отдельном сервере, называемом контроллером, и перенос функций
управления сетью из сетевых устройств в контроллер. При таком подходе
контроллер выполняет настройку сетевых
устройств, а сетевые устройства (коммутаторы) выполняют
обработку и передачу сетевых пакетов на
основе правил обработки, полученных от контроллера. То есть в ситуации,
требующей модификации правил обработки передаваемых данных (например,
отключение канала связи или появление неизвестных пакетов), сетевое
устройство обращается к контроллеру.

Основным функциональным элементом коммутатора является сетевое процессорное
устройство (СПУ).
Сетевое процессорное устройство --- это специализированная
интегральная схема, предназначенная для обработки пакетов сетевыми
устройствами.

В настоящее время активно развиваются программируемые СПУ. СПУ данного типа
позволяют как загружать новые программы обработки пакетов, так и определять
новые протоколы передачи данных~\cite{bib:Volkanov:NPUApproach}.

Обработка пакета в СПУ происходит в соответствии с программой обработки
пакетов, загруженной в СПУ.
Алгоритмы обработки пакетов, требующие хранения состояния,
применяются в сетях центров обработки данных и в сетях телекоммуникационных
провайдеров~\cite{bib:Bifulco:progDataPlane}. Состояние алгоритма
обработки пакетов --- это набор изменяемых переменных, значения которых
сохраняются при переходе к обработке следующего пакета.
Примерами являются следующие алгоритмы: алгоритм балансировки транспортных
потоков~\cite{bib:Cascone:management}, алгоритм
port-knocking~\cite{bib:Bianchi:OpenState}, алгоритм быстрого восстановления
потока пакетов после отключения канала~\cite{bib:Cascone:management}.
Главной особенностью алгоритма обработки пакетов с хранением состояния
является возможность введения зависимости процесса
обработки пакета от свойств пакетов, обработанных данным СПУ ранее.
С развитием ПКС и программируемых СПУ возникает задача реализации
алгоритмов обработки пакетов с хранением состояния на программируемых СПУ.

Если СПУ не имеет механизма хранения состояния алгоритма, то задача хранения
состояния
возлагается на контроллер. Но состояние алгоритма обработки пакетов с
хранением состояния изменяется в зависимости от
пакетов, проходящих через СПУ. Если состояние будет хранить контроллер, то
при обработке каждого пакета сетевое устройство будет обращаться к контроллеру
для обновления состояния, что приведёт к снижению производительности
сетевого устройства, вызовет сброс пакетов, замедление и нарушение
работы сетевых сервисов.

Таким образом, становится актуальной задача реализации механизма хранения
состояния алгоритма обработки пакетов в СПУ.
Данная работа посвящена разработке модификаций существующей архитектуры
программируемого СПУ, которые позволят реализовать алгоритмы обработки
пакетов с хранением состояния, не требующие синхронизации между входными
портами. В качестве примера подобного алгоритма можно назвать
алгоритм port-knocking.

\section{Цель работы}
Цель работы - разработать архитектуру программируемого СПУ, позволяющую
реализовывать алгоритмы обработки пакетов с
хранением состояния.

Для достижения цели необходимо решить следующие задачи:
\begin{enumerate}
	\item Провести обзор существующих подходов к хранению
		состояния алгоритма обработки пакетов в СПУ.
	\item Предложить модификации архитектуры существующего
		программируемого СПУ, позволяющие организовать систему
		хранения состояния алгоритма обработки пакетов в СПУ.
	\item Модифицировать программное средство, имитирующее
		архитектуру СПУ.
	\item Разработать методику экспериментального исследования
		модифицированной архитектуры.
	\item Провести экспериментальное исследование и проанализировать
		результаты.
\end{enumerate}

\section{Описание исходной архитектуры СПУ}

На рисунке~\ref{float:arch:general} представлена схема исходной архитектуры
программируемого СПУ.

\begin{figure}
	\centering
	\includegraphics[width=0.48\textwidth]{img/NPU_arch_unmod.png}
	\caption{Структурная схема СПУ.}
	\label{float:arch:general}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.48\textwidth]{img/NPU_arch_conv_unmod.png}
	\caption{Cхема конвейера СПУ.}
	\label{float:arch:conv}
\end{figure}

В ходе обработки конвейером заголовок пакета и метаданные последовательно
проходят по стадиям конвейера (Рис.~\ref{float:arch:conv}).
Каждая стадия обрабатывает заголовок пакета фиксированное число тактов.
В настоящий момент это 250 тактов.
Обработка заголовка пакета стадией конвейера происходит следующим образом:
данные полей заголовка и метаданные загружаются в область памяти стадии,
выделенную для хранения метаданных и заголовка.
После этого начинается выполнение программы, записанной в памяти стадии.
В ходе выполнения программа может модифицировать метаданные и поля заголовка
пакета. Таблицы классификации в данной архитектуре представлены в виде
деревьев поиска, представленных в коде стадии конвейера виде инструкций.
После завершения обработки пакета стадией конвейера заголовок пакета
и метаданные передаются на следующую стадию, а вместо них загружаются данные
заголовка и метаданные следующего пакета.
При этом никакие данные, оставшиеся от обработки предыдущего пакета,
не сохраняются в памяти стадии и не могут быть использованы при обработке
следующего пакета.

Рассмотрим, возможно ли применение алгоритмов обработки пакетов с хранением
состояния на данной архитектуре СПУ. Представленная
архитектура СПУ имеет два основных аспекта, препятствующие применению
алгоритмов обработки пакетов с хранением состояния. Превым аспектом является
то, что конвейеры не имеют выделенных областей памяти для хранения
состояния алгоритма обработки пакетов. Второй аспект заключается в том,
что архитектура СПУ включает набот конвейеров, работающих
параллельно и не связанных между собой. Это означает, что стадии разных
конвейеров не способны обмениваться данными для обновления состояния
алгоритма обработки пакетов во всех конвейерах.
Таким образом, данная архитектура СПУ не позволяет применять алгоритмы
обработки пакетов с хранением состояния.

\section{Постановка задачи}
Предложить модификации существующей архитектуры СПУ, обеспечивающие поддержку
механизма хранения состояния алгоритма обработки пакетов без синхронизации
состояния между портами СПУ. В силу ограничений рассматриваемой архитектуры
к модификациям архитектуры предъявляются следующие требования:
\begin{itemize}
	\item Время обработки заголовка пакета не должно превышать 250 тактов.
	\item Для каждой стадии каждого конвейера должен храниться отдельный
		набор переменных состояния.
\end{itemize}

\section{Анализ подходов к хранению состояния алгоритма обработки пакетов}
Цель обзора --- анализ особенностей аппаратных и программных подходов к
хранению состояния алгоритма обработки пакетов в сетевом устройстве.

В данном обзоре помимо аппаратных подходов к реализации механизма
хранения состояния алгоритма обработки пакетов рассмотрены и программные
подходы. В силу новизны исследуемой
тематики, архитектуры программируемых СПУ, поддерживающих механизм
хранения состояния, являются закрытыми и в литературе описаны скудно.
Таким образом, с целью определения подхода к представлению алгоритмов
и их состояний, целесообразно рассматривать и программные подходы.

\subsection{Обзор аппаратных реализаций механизма хранения состояния алгоритма
обработки пакетов}

Будут рассмотрены следующие аспекты архитектур СПУ, поддерживающих
механизм хранения состояния алгоритма обработки пакетов:
\begin{enumerate}
	\item Описание общей архитектуры устройства.
	\item Описание особенностей вычислительных ядер устройства.
	\item Связи между вычислительными ядрами.
	\item Способ хранения состояния, способ синхронизации состояния между
		ядрами.
	\item Способ изменения состояния.
\end{enumerate}

\subsubsection{Набор переменных состояния, размещённых на стадиях конвейера}
В работе \cite{bib:Sivaraman:patent} предлагается следующий подход:
архитектура СПУ содержит один конвейер.

\begin{figure}
	\centering
	\includegraphics[width=0.48\textwidth]{img/Multiple_var_m.png}
	\caption{Cхема конвейера СПУ с устройствами
	памяти~\cite{bib:Sivaraman:patent}.}
	\label{float:app:pipeline}
\end{figure}

Каждая стадия конвейера имеет набор процессорных ядер
(Рис.~\ref{float:app:pipeline}). Каждое ядро имеет собственную программу и
соединено с устройством памяти. Устройство памяти
используется для хранения переменных состояния, используемых процессорным
ядром, соединённым с этим устройством памяти. Процессорное ядро
не имеет доступа к переменным состояния, относящимся к другим процессорным
ядрам.

Вычислительные ядра на стадии конвейера не связаны между собой и выполняют
обработку заголовка пакета параллельно, каждое ядро обрабатывает
группу полей заголовка, не пересекающуюся с группами полей заголовка,
обрабатываемыми другими ядрами. В процессе обработки полей заголовка
процессорное ядро может как читать значения переменных состояния,
записанные в соответствующем ему устройстве памяти, так и записывать их.
Такой подход исключает необходимость синхронизации между процессорными
ядрами, так как они обрабатывают непересекающиеся наборы полей заголовка
пакета и имеют доступ к непересекающимся наборам переменных состояния.

Обработка заголовка пакета стадией конвейера происходит за фиксированное
число тактов.

\subsubsection{Архитектура на основе атомов}
В статье \cite{bib:Sivaraman:Banzai} предлагается модельная архитектура на
основе атомов.

\begin{figure}
	\centering
	\includegraphics[width=0.48\textwidth]{img/Banzai_rus.png}
	\caption{Cхема СПУ с конвейером на основе
	атомов~\cite{bib:Sivaraman:Banzai}.}
	\label{float:app:banzai}
\end{figure}

При данном подходе каждая стадия конвейера имеет массив атомов и таблицу
классификации (Рис.~\ref{float:app:banzai}).
Атом --- это основной элемент стадии конвейера, используемый для обработки
полей заголовка пакета. Атом состоит из вычислительного ядра и устройства
памяти для
хранения команд и данных.
Атомы одной стадии конвейера не связаны между собой, каждый атом обрабатывает
свою часть полей заголовка пакета. Каждый атом содержит устройство памяти
для хранения набора переменных состояния, доступных полько вычислительному
ядру данного атома. То есть переменные состояния распределены между
атомами стадии. При обработке заголовка пакета вычислительные ядра атомов
могут читать значения переменных состояния и записывать новые значения.

Каждая стадия обрабатывает заголовок пакета за один такт и передаёт его
следующей стадии. Механизма возврата заголовка на предыдущие стадии для
повторного прохода по конвейеру данная архитектура не предусматривает.
Это накладывает ограничения на длину программы обработки пакетов и,
следовательно, на её сложность. Чем больше стадий имеет конвейер, тем более
сложный алгоритм он позволяет использовать. Но данные ограничения
позволяют гарантировать безостановочную работу конвейера, обрабатывающего
пакеты.

Устройства памяти, находящиеся на разных стадиях конвейера, не связаны,
но существует возможность передачи значения переменной состояния на
следующие стадии конвейера. Эта возможность реализована при помощи
специальных полей в метаданных.

\subsection{Подходы к программной реализации механизма хранения состояния
алгоритма обработки пакетов}
Будут рассмотрены следующие особенности программных реализаций:
\begin{enumerate}
	\item Описание способа представления алгоритма обработки пакетов.
	\item Описание представления состояния алгоритма обработки пакетов.
\end{enumerate}

\subsubsection{Конечный автомат (реализация с двумя таблицами)}
В статьях \cite{bib:Cascone:management} и \cite{bib:Pontarelli:hardware}
предлагается следующий подход: алгоритм обработки пакетов представляется
в виде последовательности таблиц классификации, каждая таблица находится
на одной из стадий конвейера (Рис.~\ref{float:prog:table_two_general}).

Состояние алгоритма обработки пакетов представлено в виде конечного автомата.
Он представлен как система из двух таблиц, размещённых на двух
дополнительных стадиях конвейера.

\begin{figure}
	\centering
	\includegraphics[width=0.25\textwidth]{img/XFSM_two.png}
	\caption{Cхема системы хранения состояния с двумя таблицами.}
	\label{float:prog:table_two_general}
\end{figure}

\begin{figure}
	\centering

	\begin{tabular}{|c|c|}
		\hline
		Ключ & Состояние \\
		\hline

	\end{tabular}

	\caption{Структура записи в таблице состояний.}
	\label{float:prog:table2_1}
	\centerline{}
	{\small
	\begin{tabular}{|c|c|c|c|}
		\hline
		Состояние & Событие & Действия & Следующее состояние \\
		\hline

	\end{tabular}
	}
	\caption{Структура записи в таблице переходов.}
	\label{float:prog:table2_2}
\end{figure}

Первая таблица называется таблицей состояний и используется для хранения
текущего состояния потока пакетов. Структура записи в таблице состояний
показана на рисунке~\ref{float:prog:table2_1}.
Вторая таблица называется таблицей переходов и используется для получения
нового состояния на основе текущего состояния и произошедшего события.
Структура записи в таблице переходов показана на
рисунке~\ref{float:prog:table2_2}.

Важно отметить, что СПУ должен иметь механизм, позволяющий модифицировать
таблицу состояний, так как эта таблица содержит текущие состояния потоков
пакетов обрабатываемых СПУ в данный момент времени.

\subsubsection{Конечный автомат (реализация с тремя таблицами)}
В статье \cite{bib:Zhu:forwarding}
предлагается подход, при котором алгоритм обработки пакетов представлен в
виде последовательности таблиц. Механизм хранения состояния представлен
в виде конечного автомата, реализованного при помощи системы из трёх
таблиц, размещённых на трёх дополнительных стадиях конвейера
(Рис.~\ref{float:prog:table_three_general}).

\begin{figure}
	\centering
	\includegraphics[width=0.35\textwidth]{img/XFSM_three.png}
	\caption{Cхема системы хранения состояния с тремя таблицами.}
	\label{float:prog:table_three_general}
\end{figure}

\begin{figure}
	\centering

	\begin{tabular}{|c|c|c|}
		\hline
		Состояние & Событие & Следующее состояние \\
		\hline

	\end{tabular}

	\caption{Структура записи в таблице переходов.}
	\label{float:prog:table3_2}
	\centerline{}

	\begin{tabular}{|c|c|c|}
		\hline
		Ключ & Состояние & Набор действий \\
		\hline

	\end{tabular}

	\caption{Структура записи в таблице действий.}
	\label{float:prog:table3_3}

\end{figure}

В данной реализации наборы действий вынесены в отдельную таблицу.
Первая таблица используется для хранения
текущего состояния потока пакетов и имеет структуру записи, аналогичную
используемой в реализации с двумя таблицами (Рис.~\ref{float:prog:table2_1}).
Таблица переходов, используемая для получения
нового состояния на основе текущего состояния и произошедшего события,
не содержит поле, содержащее набор действий над пакетом.
Структура записи в таблице переходов показана на
рисунке~\ref{float:prog:table3_2}.
Таблица действий используется для хранения наборов действий над пакетами.
Поиск в таблице действий осуществляется по ключу и текущему состоянию потока.
Управление таблицами осуществляется при помощи протокола OpenFlow.
Структура записи в таблице действий показана на
рисунке~\ref{float:prog:table3_3}.

\subsection{Сравнение подходов}
Сравним рассмотренные аппаратные подходы к реализации алгоритма обработки
пакетов. Оба подхода предполагают использование набора изолированных
вычислительных ядер, расположенных на стадии конвейера. Состояние
алгоритма обработки пакетов представляет собой набор переменных,
хранящихся в устройствах памяти.

Рассмотренные подходы предполагают хранение состояния алгоритма обработки
пакетов в устройствах памяти, размещённых на стадиях конвейера.
При этом устройства памяти, относящиеся к разным стадиям конвейера,
не связаны.

Исходная архитектура СПУ предполагает использование одного вычислительного
ядра на каждой стадии конвейера. Таким образом, в применении к исходной
архитектуре СПУ, описанные подходы предполагают размещение устройств
памяти для хранения переменных состояния на каждой стадии конвейера.

Перейдём к рассмотрению программных подходов к реализации механизма
хранения состояния алгоритма обработки пакетов.
В рассмотренных подходах предлагается использовать модель конечного автомата
для хранения состояния и набор таблиц, сходных с таблицами классификации,
для реализации конечного автомата.

Реализация аппаратной поддержки подобных подходов может быть сходной
с реализацией аппаратной поддержки для таблиц классификации,
но потребует наличия механизма, позволяющего изменять поля записей,
соответствующие текущим состояниям потоков, обрабатываемых СПУ.

Исходная архитектура СПУ предполагает использование следующей схемы:
структура данных, используемая для поиска, представлена в виде
микрокода стадии конвейера.

Для реализации подобного алгоритма необходимо наличие на стадии конвейера
устройства памяти, хранящего структуру данных, составляющую таблицу
состояний,
и доступного на запись для вычислительного ядра в процессе обычной работы
конвейера (не в режиме обновления микрокода).

Таким образом, целесообразно рассмотреть следующий подход: размещение
на каждой стадии конвейера устройств памяти для хранения переменных состояния
алгоритма обработки пакетов.

Важно отметить, что рассмотренные реализации предполагают использование
одного конвейера, паралеллизм реализуется при помощи набора параллельно
работающих вычислительных ядер на стадиях конвейера. Целевая архитектура
СПУ предполагает использование
массива параллельных конвейеров. Таким образом, реализация механизма
хранения состояния алгоритма обработки сетевых пакетов нуждается в доработке
для работы с массивом параллельных конвейеров.

\subsection{Выводы}
В данной части была рассмотрена применимость рассмотренных подходов к
исходной архитектуре СПУ. По итогам был сделан вывод о целесообразности
применения следующего подхода: на каждой стадии конвейера размещаются
устройства памяти, хранящие переменные состояния алгоритма обработки
пакетов.

В некоторых подходах реализована таблица состояний, применяемая
для хранения состояний потоков пакетов. Данный механизм может быть
использован при модификации СПУ.


\section{Предлагаемая модификация архитектуры СПУ}

\subsection{Описание модификации архитектуры}
Для хранения состояния на каждую стадию конвейера добавляется
устройство памяти для хранения состояния~\cite{bib:Sivaraman:patent}.
Устройства памяти разных стадий не имеют связи между собой
(Рис.~\ref{float:arch_mod:general}).

В силу невозможности доступа к одним и тем же переменным состояния
при обработке пакетов, полученных с разных портов, данный подход сужает
множество алгоритмов обработки пакетов,
реализуемых на данной архитектуре СПУ. В дальнейшем будет рассмотрен
алгоритм port-knocking,
так как для него не требуется доступ к одним и тем же переменным состояния
для пакетов, полученных с разных портов.

\subsection{Модификации стадии конвейера}
На рисунке~\ref{float:arch_mod:DE_Arch} представлена схема модифицированной
стадии конвейера. Для хранения переменных состояния добавлено
устройство памяти. Оно располагается в том же адресном пространстве, что и
основная память стадии конвейера. Для выбора устройства памяти при
обращении к памяти используется блок memory selector.

Для хранения множества переменных состояния
используется таблица состояний~\cite{bib:Cascone:management}.

\begin{figure}
	\centering
	\includegraphics[width=0.48\textwidth]{img/NPU_arch_mod.png}
	\caption{Cхема модифицированной архитектуры СПУ.}
	\label{float:arch_mod:general}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.48\textwidth]{img/DE_arch_mod.png}
	\caption{Cхема модифицированной стадии конвейера.}
	\label{float:arch_mod:DE_Arch}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{img/DE_tree_node_structure.png}
	\caption{Структура узла дерева поиска.}
	\label{float:arch_mod:item_structure}
\end{figure}

\subsection{Представление таблицы состояний}
Для представления таблиц классификации в данном СПУ применяются деревья поиска.
Рассмотрим представление таблицы состояний в виде дерева поиска.
Данная структура данных хранится в устройстве памяти для хранения состояния.
Для работы с деревом поиска используется блок Tree controller,
для управления которым вводятся следующие инструкции:
\begin{itemize}
	\item {\bfseries stsearch} --- поиск по ключу, находящемуся в
		аккумуляторе. Значение записывается в аккумулятор,
		найденная запись помечается как текущая. Если запись не
		найдена, создаётся новая запись. В этом случае в
		аккумулятор записывается ноль.
	\item {\bfseries stset} --- запись нового значения в текущую запись.
		Новое значение считывается из аккумулятора.
	\item {\bfseries stdel} --- удаление текущей записи.
\end{itemize}

Данные инструкции не имеют параметров.

Для хранения дерева применяется следующий подход: каждый узел имеет размер,
равный длине машинного слова. При добавлении записи блоки памяти
заполняются последовательно. По достижении верхней границы памяти поиск
свободного блока начинается с первого блока. При удалении записи
соответствующий блок памяти помечается как свободный. Структура записи
представлена на рисунке~\ref{float:arch_mod:item_structure}.
Запись имеет следующие поля:
\begin{enumerate}
	\item {\bfseries left} --- адрес левого поддерева,
	\item {\bfseries right} --- адрес правого поддерева,
	\item {\bfseries data} --- данные, хранимые в данном узле,
	\item {\bfseries key} --- ключ.
\end{enumerate}
Размер полей left и right зависит от размера памяти для хранения состояния.
Размер полей key и data задаётся при загрузке программы в СПУ.

Рассмотрим устройство блока Tree controller. Данный блок имеет следующие
регистры:
\begin{itemize}
	\item {\bfseries item} используется для хранения текущего узла дерева,
	\item {\bfseries search} содержит адрес текущего узла дерева,
	\item {\bfseries key\_size} содержит размер ключа,
	\item {\bfseries data\_size} содержит размер поля данных.
	\item {\bfseries alloc} содержит адрес последнего блока памяти,
		выделенного для дерева поиска.
\end{itemize}
При загрузке программы в СПУ в регистры key\_size и data\_size записываются
длины полей key и data (в битах).

\subsection{Использование алгоритмов обработки пакетов без хранения состояния}
В том случае, если используемый алгоритм обработки пакетов не требует
хранения состояния, он может быть выполнен на данной архитектуре
без использования устройств памяти для хранения состояния. В этом
случае работа данной архитектуры СПУ аналогична работе
исходной архитектуры СПУ.


\section{Описание разработанного программного средства}

\subsection{Имитационная модель СПУ}
За основу взято программное средство, представляющее собой имитационную
модель конвейера исходной архитектуры СПУ на языке программирования Python,
позволяющее настраивать количество вычислительных ядер, оценивать
энергопотребление и площадь кристалла.
В ходе работы имитационная модель выводит следующую информацию:
\begin{itemize}
	\item Среднее количество тактов на обработку пакета.
	\item Пропускная способность.
	\item Среднее энергопотребление.
\end{itemize}

Структура программной реализации показана на
рисунке~\ref{float:model:structure}. Модули, отмеченные зелёным
фоном, были добавлены в ходе модификации.
Программная реализация состоит из следующих модулей:
\begin{itemize}
	\item {\bfseries Application} --- основной модуль программы.
	\item {\bfseries Pipeline} --- модуль, имитирующий работу конвейера.
	\item {\bfseries InFIFO} --- модуль, имитирующий работу входной
		очереди. В данном модуле происходит чтение pcap файлов с
		пакетами, подаваемыми на входные порты.
	\item {\bfseries OutFIFO} --- модуль, имитирующий работу выходной
		очереди. В данном модуле происходит запись pcap файла,
		соответствующего данному порту.
	\item {\bfseries DE}. Данный модуль имитирует работу вычислительного
		ядра.
	\item {\bfseries Memory} --- модуль, имитирующий работу устройства
		памяти, находящегося на стадии конвейера.
	\item {\bfseries Context} --- модуль, хранящий состояние
		вычислительного ядра (адрес текущей инструкции,
		значение аккумулятора, регистра сдвига).
	\item {\bfseries Packet memory} --- модуль, имитирующий работу
		устройства памяти, используемого для хранения тел пакетов.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{img/Prog_structure.png}
	\caption{Структура программной реализации.}
	\label{float:model:structure}
\end{figure}

В ходе модификации были добавлены следующие модули:
\begin{itemize}
	\item {\bfseries State memory}. Данный модуль имитирует работу
		устройства памяти для хранения состояния.
	\item {\bfseries Tree controller}. Данный модуль имитирует работу
		блока Tree controller. В ходе его работы происходит расчёт
		количества тактов, потраченных на работу с деревом поиска.
\end{itemize}

Для конфигурирования имитационной модели были добавлены следующие параметры:
\begin{itemize}
	\item Размер памяти, используемой для хранения кода, заголовка и
		метаданных. Размер памяти для хранения состояния
		определяется как разность размера памяти стадии и размера
		памяти, используемой для хранения кода.
	\item Описания инструкций stsearch, stset, stdel: их коды и
		описания параметров.
\end{itemize}

Добавлены аргументы командной строки {\tt --state-tree-key} и
{\tt --state-tree-data}, задающие размеры ключа и поля данных узла
дерева поиска.

Также в ходе модификации был добавлен вывод максимального количества тактов,
поторебовавшихся на обработку одного пакета.

\section{Экспериментальное исследование}
Целью экспериментального исследования является оценка количества тактов,
требуемых для обработки пакета модифицированным СПУ в зависимости от
количества потоков пакетов, обрабатываемых СПУ. В силу того, что в данном
СПУ на обработку пакета выделяется фиксированное количество тактов,
необходимо исследовать количество тактов, необходимых для обработки
пакета алгоритмом, хранящим состояние каждого потока.

Помимо этого в ходе экспериментального исследования оценивается
пропускная способность и энергопотребление СПУ.

\subsection{Методика исследования}
Экспериментальное исследование проводится для алгоритма
port-knocking~\cite{bib:Bianchi:OpenState}.
Для проведения исследования написана программа на языке ассемблера,
реализующая алгоритм port-knocking.

Данный алгоритм работает следующим образом: для того чтобы пакеты данного
потока были переданы далее по сети, первые пакеты потока должны
иметь определённые номера портов назначения. Если последовательность номеров
портов не
является верной, то пакеты будут сброшены. Таким образом, для каждого
потока хранится номер текущего состояния, от которого зависит
следующий ожидаемый номер порта, а также то, будет ли пакет сброшен или
передан далее по сети.

Генерация экспериментального трафика происходила следующим образом:
была записана TCP сессия, в ходе которой было передано 12 пакетов.
Далее к данной последовательности были добавлены 4 пакета с номерами портов,
соответствующими программе, реализующей алгоритм port-knocking.
Далее на базе полученной последовательности пакетов было сгенерировано
требуемое количество потоков с другими номерами портов. Полученные
последовательности пакетов были объединены в одну последовательность
путём поочерёдного добавления к итоговой последовательности пакетов из
сгенерированных последовательностей.

В ходе экспериментального исследования производится запуск имитационной
модели с различным количеством потоков в обрабатываемых пакетах.
Размер памяти для хранения состояния установлен в 32 КБ на стадию.

\begin{table}[!b]
	\centering

	\caption{Результаты экспериментального исследования.}
	\begin{tabular}{|p{0.07\textwidth}|p{0.07\textwidth}|p{0.07\textwidth}|
		p{0.07\textwidth}|p{0.07\textwidth}|}
		\hline
		Количество потоков
		&
		Среднее число тактов на пакет
		&
		Максимальное число тактов на пакет
		&
		Энергопотребление, мВт
		&
		Пропускная способность, пакетов/с
		\\
		\hline
		500   & 32 & 50 & 10814 & 30393866\\
		\hline
		1000  & 35 & 56 & 10812 & 28506322\\
		\hline
		1500  & 36 & 65 & 10812 & 27224990\\
		\hline
		2000  & 35 & 81 & 10812 & 27926013\\
		\hline
	\end{tabular}
	\label{float:res:result}
\end{table}

\subsection{Результаты исследования}
Были проведены запуски имитационной модели для 500, 1000, 1500 и 2000
потоков. Результаты представлены в таблице~\ref{float:res:result}.

Для рассмотренных случаев количество тактов, поторебовавшихся для
обработки пакета, не превышает максимально допустимого, равного 250 тактам.
Среднее энергопотребление составляет 10,8 Вт, средняя пропускная способность
составляет 28512798 пакетов в секунду.


\section{Заключение}
В ходе выполнения работы получены следующие результаты:
\begin{itemize}
	\item Проведён анализ существующих подходов к хранению
		состояния алгоритма обработки пакетов в СПУ на основе
		которого были определены подходы для модификации
		архитектуры СПУ.
	\item Предложены модификации архитектуры существующего
		программируемого СПУ, позволяющие организовать систему
		хранения состояния алгоритма обработки пакетов в СПУ
		без синхронизации состояния между портами СПУ.
	\item Модифицировано программное средство, имитирующее
		архитектуру СПУ.
	\item Разработана методика экспериментального исследования
		модифицированной архитектуры. Проведено экспериментальное
		исследование модифицированной архитектуры.
	\item По результатам экспериментального исследования установлено,
		что предложенный подход применим. Оценено энергопотребление
		и пропускная способность СПУ.
\end{itemize}

В силу отсутствия механизма синхронизации между устройствами
памяти разработанная архитектура не позволяет применять алгоритмы обработки
пакетов, требующие доступ к одним и тем же переменным состояния
для обработки пакетов, полученных с разных портов. Таким образом,
возможны дальнейшие исследования с целью разработки подобного механизма,
что позволит расширить спектр алгоритмов обработки пакетов,
реализуемых на данной архитектуре. Также в дальнейшем можно провести
исследование для конкретных протоколов с хранением состояния,
например, AFDX~\cite{AFDX}.


\begin{thebibliography}{00}

\bibitem{bib:Sivaraman:patent} Kaushalram~A.~S., Budiu~M., Kim~C.
\emph{Data-plane Stateful Processing Units in Packet Processing Pipelines}:
заяв. пат. 14864088 США. – 2017.

\bibitem{bib:Sivaraman:Banzai} Sivaraman~A. et al.
\emph{Packet Transactions: High-level Programming for Line-rate Switches}
// Proceedings of the 2016 ACM SIGCOMM Conference. – ACM, 2016. – С.~15--28.

\bibitem{bib:Bianchi:OpenState} Bianchi~G. et al. \emph{OpenState:
Programming Platform-independent Stateful Openflow Applications Inside the
Switch} // ACM SIGCOMM Computer Communication Review. – 2014. – Т.~44. – №~2.
– С.~44--51.

\bibitem{bib:Cascone:management} Cascone~C. et al. \emph{Traffic Management
Applications for Stateful SDN Data Plane} // 2015 Fourth European Workshop
on Software Defined Networks. – IEEE, 2015. – С.~85--90.

\bibitem{bib:Pontarelli:hardware} Pontarelli~S. et al. \emph{Stateful
Openflow: Hardware Proof of Concept} // 2015 IEEE 16th International
Conference on High Performance Switching and Routing (HPSR). – IEEE, 2015.
– С.~1--8.

\bibitem{bib:Zhu:forwarding} Zhu~S. et al. \emph{Sdpa: Enhancing Stateful
Forwarding for Software-defined Networking} // 2015 IEEE 23rd International
Conference on Network Protocols (ICNP). – IEEE, 2015. – С.~323--333.

\bibitem{bib:Smelyanskiy:SDN} Смелянский~Р.~Л. \emph{Программно-конфигурируемые
сети} // Открытые системы, №~9, 2012, С.~15--26.

\bibitem{bib:Kornaros:embeddedSystems} Kornaros~G. (ed.). \emph{Multi-Core
Embedded Systems.} -- CRC Press, 2010.

\bibitem{bib:Volkanov:NPUApproach} Беззубцев~С.~О., Васин~В.~В., Волканов~Д.~Ю.
и др. \emph{Об одном подходе к построению сетевого процессорного устройства}
// Моделирование и анализ информационных систем. - 2019. - Т.~26, №~1. --
С.~39--62.

\bibitem{bib:Bifulco:progDataPlane} Bifulco~R., Retvari~G. \emph{A Survey on
the Programmable Data Plane: Abstractions, Architectures and Open Problems}
// International Conference on High Perfomance Switching and Routing (HPSR). --
IEEE, 2018. -- C.~1--7.

\bibitem{AFDX} \emph{Aircraft Data Network. Part 7. Avionics Full Duplex
Switched Ethernet (AFDX) Network} // Aeronautical Radio, Inc. 2012.

\end{thebibliography}

\end{document}
